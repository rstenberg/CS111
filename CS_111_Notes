Class moving to WGYoung CS 24

Office Hours	(4532JJ Boelter):
M 10 -11
W 13:30 - 14:30

Exams:
Midterm - 5th Week
Open notes/book
1 question: write code
Other questions: conceptual questions about OS
	- provide reasonable and well supported answers

Textbook:
(AD) Operating Systems: Three Easy Pieces (OSIEP) (2016) by Andrea Arpaci-Dusseau
(SK) Principles of Computer Systems Design (2009) by Jerome H. Saltzer and M. Frans Kaashoek

Prep for class 2:
	AD: 1-2 36
	SK: 1, 2-2.3
	Interface Stability by Mark Kampe

Tests will be run on:
lnxsrv09

----------------------- Class 1 (1/9) ------------------------

"We don't offer a ready-made programme, but an entire operating system."
	- Marina Weisland (The Economist 2013-01-105 p.19)

Other OS in the news
	1. Alexa. Amazon's Operating System personal assistant cloud-based O.S. creates framework for smart devices
	2. Crouton on Chromebook <- Ubuntu in a browser tab
	3. Red Star OS - North Korean OS
		- Version 3.0
		- Mac OS like interface
		- Watermark all files
		- Attempts to prevent modifications to OS

"System" - defined
	1. An organized or connected group of objects
	2. A set of principles, etc., a scheme, method
	3. A set of interconnected components that has a specified behavior observed at the interface with its enbironments

		Environment
	-----Interface-----
	|  	  System  	  |
	-----Interface-----
		Environment

Interfaces:
	1. Interfaces is the boundary between system and interface
	2. Interface is a MAJOR limiting factor on an OS
	3. System can only be utilized to the extent of the interface

"Operating System" (important terms in curly brackets - {important})
	1. Sofware designed to {control} the {hardware of a specific data processing system} in order to allow users and application programs to make use of it
	2. Master {control} program in a computer
	3. System software that {manages} computer hardware and software {resources} and provides common services for compiler programs

Operating System
	1. Give users the power to control hardware of specific data processing system
	2. Tightly coupled to hardware

Prolems within computer systems
	1) Incommensurate scaling: not everything scales at the same rate
		Diseconomies of scale
			Ex: star network - all inputs are connected to all other networks, exponential growth
			Can cause breakage as you grow
		Economies of scale
			Ex: pin factory - much more efficient for one person to buy one long piece of wire, and fashion all 10,000 pins at once
			Can cause wasting (over production)
	2) Emergent properties - properties of the system that arise as you scale
		Qualitatively different, often unanticipated
		Ex: Tacoma Narrows - largest bridge ever built, hadn't thought about resonant frequency due to wind
		Ex: UCLA Wifi - student dorms at UCLA used to download/send illegal content
	3) Propogation of effects (butterfly effect)
		Happens to often in OS
		Ex: SJIS encoding - Microsoft used 2 bytes to represent each character
			- First bite was a '1' to signify SJIS encoding
			- Left 2^15 character arrangements
			- SJIS encoding leaked into file directory system (ascii based)
			- If '\' byte was found within a 2-byte representation of a japanese character, it was read as a file separator instead of part of japanese character
	4) Tradeoffs
		Waterbed effect - pushing down on one side of bed moves another part up
		Fixing one thing may affect other things and make the system as a while more complicated
		Ex: time-space balancing
	5) Complexity
		Moore's Law: Need for # transisotr's on a computer increases logarithmically
		Kryder's Law: Disk Drive Capacity increases exponentially
		Computer's are not getting faster (cannot keep up with size of disk drive)

----------------------- Class 2 (1/11) - Booting ------------------------

Interface Evolution - (i.e. internet browsers)
	Changing the interface can be messy because every program must be changed to handle the interface change

	Options attempting to allow remote access to files:
		1) fd = open("file/path", O_RDONLY,);		// makes a system call to open a read-only file and return a descriptor for it
			// Original method which does not provide remote access
		2) fd = open("google.com", "file", O_RDONLY);
			// Problem: function will have difficulty distinguishing 2 argument open from 3 argument open at runtime (won't work)
		3) fd = open("file/path", O_RDONLY, O_REMOTE);
			// Problem: will require interface to be changed drastically, which means changing source code of each application to accomodate (will work, but a lot of work)
		4) open("code.com:file", O_RDONLY);
			// ':' used to signify remote_host:file
			// ':' steals a possible character from filenames - ':' (not ideal)
		5) putenv("FILESERVER=code.com")
			fd = open("file", O_RDONLY);
			FILESERVER=code.com cat f2
			// Problem: Changing environment doesn't allow for multiple parameters
		6) fd = open("file\0code.com", O_RDONLY);
			// '\0' used to signify separation of file\0remote_host
			// Problem: operating system can't tell the difference between original open call and this list of parameters (won't work)
		7) fd = open("code.com/file", O_RDONLY);
			// Problem: directories often have '.' in their name so "code.com" could be a local directory name
		8) fd = open("/u/class/cs111/file", O_RDONLY);
			// "/u/class/cs11" means go look on the remote file system
			// Uses a VERY specific string of "directory" to dictate a remote file system
			// Used on SEASNET server to access remote file systems
			// Table created on SEASNET server to reserve this path name for a remote server

Sample app - no OS:
	Paranoid professor - 10,000 word limit file
	Desktop computer not connected to the internet or the wall power (battery powered)
	Intel core i3-4160 (3 MiB L3 cache 3.6 Ghz)
	Power switch turns on and the monitor tells you how many words are in the file
	Words match [A-Za-z]+ regex
	File is an array of bytes (ASCII) stored on the disk drive

	Priorities in order
	1) Security
	2) Speed

	Questions we need answered:
		- Where is the file located?
			Answer: sector 1,000,000
		- How do we access the file?

	Process:
	1) Turn computer on
	2) Program runs
		- Count words that match [A-Za-z]+ regex expression
		- Increment word counter when hitting non-repeating a character not in expression
		- Display word count

	Disk Drives
		- Rotating magnetic device
		- Separated into sections
		- Closed off from air to prevent dust
		- Disk drive is never touched in fear of scratching
		- To access: controller places read-write head on disk and waits for disk to spin to location that desired data is located
		- Bits of data are arranged in concentric, circular paths called tracks
		- Each track is broken up into smaller areas called sectors (512 bytes per sector)
		- Can send commands or data from CPU to controller
		- History:
			Western Digital
				Integrated Device Electronics (IDE)
				Disk controller: Added a controller that was separate from CPU in 1986
					- Attached to disk drive (ATA = AT Attachment, modernly called PATA = Paralel ATA)
					- Now each controller was tailored to its disk drive and people writing the OS didn't have to handle the controller as well
					- Has a small cache
					- CPU -> 16-bit bus --------------> (controller) -> disk drive
			Modern disk drive implementation
				SATA (Serial ATA)
					Parallel synchronization kills performance
					Hot plugging: can unplug disk drive while drive and CPU are running without causing a fire
					CPU ----- 1-bit-wire -----> controller -> disk drive

	Boostrapping
		- x86 components important to booting:
			1) Physical RAM
				Two main parts:
					a) Real DRAM (real memory)
					b) ROM (Read only memory) 
						- Location on RAM is hardwired into hardware (0xffff0)
						- Contents survive a power outage
						- Stored in EEPROM (Electronically Erasable Programmable Read-Only Memory)
							Set by the manufacturer
							Normally:
								i) 		Tests system
								ii) 	Walk through bus looking for devices
								iii) 	Finds a bootable device
								iv) 	Read device's first sector (512 bytes) into RAM
										- memory location 0x7c00 hardwired into the BIOS
										- memory location 0x7c00 to 0x7dff is modified (512 bytes)
								v)		Jump 0x7c00
						Master Boot Record (MBR) - 512 Bytes (sector 0)
							[||||||||||||  64  |2]
							final 2 byte sector
								- located at 0x55 and 0xAA 0xAA55 (little endian)
								- Boot Signature
							64 bytes: describes an area of disk
								- Contains start sector on disk
								- Size (# sectors)
								- Type (1 byte descriptor of partition, i.e. linux file system, swap partition, microsoft operator)
								- Bootable flag (specifies whether or not it is bootable)
							486 Bytes:
								- x86 code
								- Will be read into memory and executed
						Volume Boot Record (VBR)
							- Using BIOS -> MBR -> VBR = chain loading
							- Runs program called Grand Unified Bootloader (GRUB)
								- Linux Kernal
							- 1 sector of bootable partition


	BIOS
		Job:
			1) Get first sector into RAM
			2) Start running it

	Overview:
		BIOS -> MBR -> VBR -> execute word count code

	Solution to problem above:
		1) BIOS loads in MBR
		2) Jump to 0x7c00 (1st 446-bytes of MBR) and execute Boot Loader source code
		3) This source code will send word count program to RAM to execute

	Boot loader source code
		// At location 0x7c00 run the following code
		// read-write 20 sectors
		// first-argument: sector number
		// second argument: memory address
		// copy data out of disk sector to memory
		// read_ide_sector will read 446 MBR code

		#include <stdbool.h>

		void read_ide_sector(int s, int a)	{
			//PIO
			
			// **************** inb ******************
			// inb is a machine instruction on x86
			// Grabs byte off bus from status register at location 0x147 (
			// Returns current status of disk controller
			// If top two bits of status are 0x40 then it is ready
			// **************** inb ******************
			while((inb(0x147) & 0xc0) != 0x40)
				continue;

			// **************** outb ******************
			outb(0x1f2, 1);					// Setup disk controller to operator on 1 sector w/ next command
			outb(0x1f3, s & 0xff);			
			outb(0x1f4, (s >> 8) & 0xff);
			outb(0x1f5, (s >> 16) & 0xff);
			outb(0x1f6, (s >> 24) & 0xff);
			outb(0x1f7, 0x20); 				// Read sector
			// **************** outb ******************

			// **************** insl ******************
			insl(0x1f0, a, 512 / 4)
		}

		// Read from disk
		for (i=1; i< 20, i++)	{
			read_ide_sector(i, 0x10000 + (i-1)+512)
		}

		void main(void) 	{

			long nwords = 0;
			bool inword = false;
			unsigned s = 10000;

			while(true)	{
				char buf[512];
				read_ide_sector(s++, (int)buf);
				for ( int j = 0; j < 512; j+1)	{
					if (buf[j] == '\0')	{
						write_out(nwords);

						// Do not want to return program because there is nothing to return to
						// Sit in infinite loop to display word count forever
						while (true) continue;
					}
					bool thisalpha = isalpha(buf[j]);
					nwords += ~inword & thisalpha;
					inword = thisalpha;
				}
			}
		}

----------------------- Class 3 (1/18) ------------------------

memory mapped I/O
ram 	[      |       |      ]
				^0xb8000 address	80x25 grid of 16-bit characters
									80x25x2 = 4000 bytes
		Low order 8 bits Ascii characters
		High order is color = 7 (grey on black)

void write_out(long n)	{

	// Pointer that points at center of screen ofset to right slightly (to account for leng of string)
	unsigned char *screen = (unsigned char*)(0xb800 + 80*25*2/2 + 8);
	do	{
		screen[0] = n%10 + '0';
		screen[1] = 7;	// Set grey color
		screen -= 2;
		n /= 10;
	} while(n != 0);

}

	/********* Problems with original code above (has been modified now) ************

	1. integer overflow given a big file (could be trillions of words and int holds ~billion)
	2. read_ide_sector has multiple copies
		- word count program  	<- remove copy
		- in MBR				<- remove copy
		- in EEPROM @ 0x7f000		<- wc program and MBR must know location in ROM
					^Often called BIOS
	3. Busy-waiting
		Solution: **** Double Buffering ****
			- use CPU to count words while waiting for next sector to be read in
			wc countwords 				 1 2 1 ...	(CPU)
				wait for next sector 	1 2 1 2 ... (I/O)
	4. DMA (Direct Memory Access)
		Problem: How "insl" works: must cross bus twice

		|--- CPU  ----|
		--------------- bus ---------------
		RAM			  ^------------- disk controller

		Solution: DMA
			- Disk controller does the heavy lifting
		--------------- bus ---------------
		RAM <----------------------- disk controller
	5. Run several apps simultaneously
	6. (UEFI) Unified Extensible Firmware Interface
		- smarter firmware that remembers and trusts specific GUIDs
		- standard format for bootloader (EFI)
		- Globally unique identifiers (GUID)
			for partitions (128-bit nums)
		- GUID Partition table (GPT)
			- standard format of GUIDs that lives on disk or flash drive
			- interpreteble by the firmware
		- EFI partions us MS-DOS file formats
		- UEFI boot mgr
			- in firmware
			- configurable via NVRAM
			- read GPT tables off your devices
			- can access files in DOS format
			- can run EFI programs
	**********************************************************************************/

	Our program is bad practice to include in booting:
		- is too much of a pain to change
		- is too much of a pain to reuse code in other programs
		- is too much of a pain to run several programs simultaneously
		- is too much of a pain to recover from faults
		- Conclusion: we don't want other programmers to have to worry about handling our program during booting

	/ ************************** Modularity **************************
		A) Break program into pieces 
			1. wc
			2. read_ide_sector
			3. write_out
			4. etc...
		B) Software engineering advantage
			1. N lines of code (LOC)
			2. K modules
			3. Bugs ~ LOC
			4. Time to find a bug ~ LOC
			5. Debug time: Bugs * N --> O(N^2)
			Solution:
				- with K modules: (Bugs/K) * (N/K) * K --> O(N^2/K)
		C) Modularity can be good or bad
			1. You need metrics
				(a) Performance 									(generally hurt by modularity)
				(b) Robustness 										(generally helped by modularity)
					- tolerance of error in HW + SW
				(c) Flexibility/Neutrality/Lack of Assumptions		(generally helped by modularity)
				(d) Simplicity										(generally helped by modularity)
					- easy to learn/use
		D) How to implement Modularity
			/ *********** NO MODULARITY ************ /
			0) Don't do it

			/ *********** SOFT MODULARITY ************ /
							(Not ideal)
			1) Function call (caller/callee modularity)
				(a) Example:
						int factorial(int n)	{
							if (n == 0)	
								return 1;
							else
								return n * factorial(n-1);
						}

						// Assembly code
						factorial
							pushq %rbp
							movq  %rsp, %rbp
							subq  $16 %rsp
							movl  %ed, -4(%rbp)
							cmpl  $0, -4(%rbp)
							jne   .L2			// else statement
							movl  $1, %eax
							jmp   .L3			// return 1 instruction

						.L2
							movl  -4(%rbp), %eax
							subl  $1, %eax
							movl  %eax, %edi
							call  factorial
							imull -4(%rbp), %eax

						.L3
							ret

				(b) What can go wrong?
					Callee has too much power
						- Callee can read the passwords that caller handles
						- Callee can fudge return address to return elsewhere
						- Callee can fudge memory that is in caller's stack (stack overflow)
						- Callee can mess with Caller's registers
						- Callee can loop forever (never return to caller)
					Caller also has too much power
						- Caller can set stack pointer to 0 before jumping to callee
						- Caller can jump into middle of callee instead of begining
					Caller/Callee modularity is ALL based on trust
			
			/ ********* HARD MODULARITY ********** /
							(ideal)
			2) Ways to get hard modularity
				(a) Client/Server (Use different computers each module)
					i) communicate via a network API
					ii) Dangers
						- Only works if:
							* lots of computation, low communication
							* large modules, low communication
						- If network goes down, can no longer communicate
						- If bug exists in API then client could find way to mess with server
						- Hassle to set up
						- More resources (2 computers and a network)
					iv) Benefits
						- Client can only send requests
						- Client cannot directly modify memory (no shared state/memory)
						- If client/server enters infinite loop/crash, other side can continue its job
				(b) Virtualization
					i) One computer pretending to be 2+ computers
						- [Client|Server]    rather than     [Client] <--> [Server]
						- One computer and one CPU
					ii) Methods of Virtualization
						(a) Emulator
							- Interpreter that runs all client code with checks
								Example: ARM emulator on SEASnet x86-64
									interp.c
										execute_inst(char *ip)	{
											// interpret and execute x86 instruction set
											// checks memory addresses
											// if trying to access improper memory, return -1; (fail)
											// put timeout requirements on function calls
										}
							- Negatives: Too slow
							- Positives: Easier for developers to debug
						(b) Hardware support
							- Unpriviledged instructions (99.99%)
								* run at full speed
								* ex:  addq $1 %eax
							- Priviledged instructions (0.01%)
								* Don't run at all
								* Cause hardware traps 
									-> Internst service vector trap array
										# Array and trap handling functions are stored in protected memory (read_only)
										# Divide by 0 might be trap 3
										# Bad pointer might be trap 4
										# Each element in array is a pointer to code that runs when its corresponding trap is hit
											> Protected transfer of control (user -> OS)
										# Trap handlers 128 - 255 are designed for users to use in conjunction w/ system calls (e.g. read)
									-> Trap saves (On the stack / in memory)
										# Stack pointer
										# Instruction pointer
										# Flags
											> Including privileged flag
										# Stack segment
										# Code segment
										# Error code
									-> Trap handlers behave similar to function calls, but...
										# More expensive (save more things than functions)
										# Call made by invalid instruction
										# Return made by "rti" (return from interrupt) assembly command
										# Can execute privileged instructions
								* ex:  halt (wouldn't want students calling halt on SEASnet server)
							- Example:
								char buf[511];
								read(0, buf, 512);
									^--- read: 	push $12
												int 128   // simulate hardware interrupt and call trap handler 128
							- Speeding up system calls
								* x86 system calls
									-> sysenter
										sets cs, ecp, ss, esp to values set n model-specific registers (protected)
									-> sysexit
										sets 	ecp <- edx
												esp <- ecx
												cs, ss from m
								* x86-64 system calls
									-> syscall
										args: 		rdi, rsi, rdx, r10, r8, r9
										outputs: 	destroys rcx, r11 (temporary registers to use, values inside get destroyed after)
										result: 	rax
								* Linux VDSO (Virtual dynamically linked shared object)
									Example:
										$ ldd /bin/sh
										linux-vdso so1 => (0x47744000)
										syscall code is stored ^ in kernel at /bin/sh and can only be executed by kernel
							- Negatives:
								* Talking to memory is too slow
							- Diagram:
								_________________________
								|	   Application		|
								|						|
								|_________ 				|
								| Kernel |				|
								|-----------------------|
								| Hardware				|
								|						|
								-------------------------
							- Hardware Support Options
								(a) stdio level
									* ex: getchar, putchar
								(b) syscall level
									* ex: read, write
								(c) Ring structured OS
									* Kernel -> virtual memory -> files -> application
									* Can only access layers that are further out in the ring
									* Problem: expensive to constantly jump back to kernel
									* Diagram: fill in rest of rings as above
										____________
										|	Files 	|
										|	_______ |
										|	|  _  |	|
										|	| |_| |	| App
										|	|_____|	|
										|			|
										|___________|
								(d) Linux: Monolithic Kernel
									* Trade security for performance
					iii) Organization via Virtualization
						(a) ALU (Arithmetic Logic Unit)
						(b) User code has full access to:
							- User memory
							- rbp, rsp, rcx, rip
						(c) Primary memory (limited access)
							- Flags
							- ISV
						(d) I/O (no access, only through syscalls)
					iv) Process
						(a) Program in execution in an isolated domain (not aware of parallel programs)
						(b) Run on virtualizable processor
							- Processor that can pretend to be multiple machines
							- Create new process through a syscall
								* pid_t fork(void);
									-> Child == parent except:
										PID are different
										PPID are diff (parentPID)
										File descriptors start the same (but can now be modified without changing them in other processes)
										Accumulated execution times
										File locks (child has none)
										Pending signals ("")
							- Create new program through syscall
								* int execvp(char const *file, char const **argv);
									-> Opposite of fork, new of the following:
										Program
										Data
										Registers
										Signal handler & reset

				

		E) Modularity when creating OS
			1) Goals
				(a) Protection
				(b) Robustness
				(c) Utilization
				(d) Performance
				(e) Flexibility
				(f) Flexibility
				(g) Simplicity
			2) System Abstractions
				(a) Memory
					i) load + store
					ii) read + write
					iii) size?
					iv) word_size?
					v) throughput
					vi) Lotery
					vii) volatility
						- Volatile memory goes away when computer turned off
						- Non-volative memory is stored (want user to BELIEVE everything is non-volatile)
					viii) Linear vs associative
					ix) Coherrence
				(b) Interpreter
					i) Environment pointers
						- Where is stack? (pointer to address)
						- Repetoire
							* instruction pointers
						- Normal execution vs. exceptional execution
							* throw
							* trap: system crash, but catch and continue
				(c) Links
					(i) send + receive
						- e.g. I/O Bus
						- send address, receive data
						- gives developer asynchronus behavior (unlike memory loading)
			3) Selection: Hardware support
				(a) stdio level
					ex: getchar, putchar
				(b) syscall level
					ex: read, write
				(c) Ring structured OS
					- Kernel -> virtual memory -> files -> application
					- Can only access layers that are further out in the ring
					- Problem: expensive to constantly jump back to kernel
				(d)


	******************************************************************/

// ***************** Discussion: Lab0 / Lab 1A overview ***************** //
Lab 0:
	Read/Write permissions:
		ex: 0644    special: 0(none)
					user: 6 = 4 + 2	(rw)
					group: 4(r)		
					other: 4(r)

	File descriptor	:	default file
	0 				:	stin
	1 				: 	stdout
	2 				: 	stderr
	3 				: 	(open)
	...
	100 			: 	(open)
	...
	...
	...
	Opening a file sets the next avaiable file descriptor to point at the file

	dup2(int oldfd, int newfd, int flag)
	Makes newfd be the copy of oldfd, closing newfd first if necessary

Lab 1:
	Shell script parser
	Test case in spec cannot be passed LOL

	--verbose
	printf("--command 3 5 6 tr A-Z a-z") just before the option is implemented

	Multiple processes:
		pid_t fork(void);
		On success, the PID of the child process is returned in the parent,
		and 0 is returned in the child.  On failure, -1 is returned in the
    	parent, no child process is created, and errno is set appropriately

    	ex:
    		pid_t pid = fork();
    		if (pid == 0)	{
    			// have child process do something
    		}	else if (pid > 0)	{
    			// have parent process do something
    		}	else 	{
    			printf("Error forking processes");
    		}

    	Re-syncing processes:
    		pid_t waitpid(pid_t pid, int *wstatus, int options);

    Execline:
    	int execvp(const char *file, char *const argv[]);
    	Wipes out data but keeps file redirection (stdin, stdout, stderr, etc.)


