Class moving to WGYoung CS 24

Office Hours	(4532JJ Boelter):
M 10 -11
W 13:30 - 14:30

Exams:
Midterm - 5th Week
Open notes/book
1 question: write code
Other questions: conceptual questions about OS
	- provide reasonable and well supported answers

Textbook:
(AD) Operating Systems: Three Easy Pieces (OSIEP) (2016) by Andrea Arpaci-Dusseau
(SK) Principles of Computer Systems Design (2009) by Jerome H. Saltzer and M. Frans Kaashoek

Prep for class 2:
	AD: 1-2 36
	SK: 1, 2-2.3
	Interface Stability by Mark Kampe

Tests will be run on:
lnxsrv09

----------------------- Class 1 (1/9) ------------------------

"We don't offer a ready-made programme, but an entire operating system."
	- Marina Weisland (The Economist 2013-01-105 p.19)

Other OS in the news
	1. Alexa. Amazon's Operating System personal assistant cloud-based O.S. creates framework for smart devices
	2. Crouton on Chromebook <- Ubuntu in a browser tab
	3. Red Star OS - North Korean OS
		- Version 3.0
		- Mac OS like interface
		- Watermark all files
		- Attempts to prevent modifications to OS

"System" - defined
	1. An organized or connected group of objects
	2. A set of principles, etc., a scheme, method
	3. A set of interconnected components that has a specified behavior observed at the interface with its enbironments

		Environment
	-----Interface-----
	|  	  System  	  |
	-----Interface-----
		Environment

Interfaces:
	1. Interfaces is the boundary between system and interface
	2. Interface is a MAJOR limiting factor on an OS
	3. System can only be utilized to the extent of the interface

"Operating System" (important terms in curly brackets - {important})
	1. Sofware designed to {control} the {hardware of a specific data processing system} in order to allow users and application programs to make use of it
	2. Master {control} program in a computer
	3. System software that {manages} computer hardware and software {resources} and provides common services for compiler programs

Operating System
	1. Give users the power to control hardware of specific data processing system
	2. Tightly coupled to hardware

Prolems within computer systems
	1) Incommensurate scaling: not everything scales at the same rate
		Diseconomies of scale
			Ex: star network - all inputs are connected to all other networks, exponential growth
			Can cause breakage as you grow
		Economies of scale
			Ex: pin factory - much more efficient for one person to buy one long piece of wire, and fashion all 10,000 pins at once
			Can cause wasting (over production)
	2) Emergent properties - properties of the system that arise as you scale
		Qualitatively different, often unanticipated
		Ex: Tacoma Narrows - largest bridge ever built, hadn't thought about resonant frequency due to wind
		Ex: UCLA Wifi - student dorms at UCLA used to download/send illegal content
	3) Propogation of effects (butterfly effect)
		Happens to often in OS
		Ex: SJIS encoding - Microsoft used 2 bytes to represent each character
			- First bite was a '1' to signify SJIS encoding
			- Left 2^15 character arrangements
			- SJIS encoding leaked into file directory system (ascii based)
			- If '\' byte was found within a 2-byte representation of a japanese character, it was read as a file separator instead of part of japanese character
	4) Tradeoffs
		Waterbed effect - pushing down on one side of bed moves another part up
		Fixing one thing may affect other things and make the system as a while more complicated
		Ex: time-space balancing
	5) Complexity
		Moore's Law: Need for # transisotr's on a computer increases logarithmically
		Kryder's Law: Disk Drive Capacity increases exponentially
		Computer's are not getting faster (cannot keep up with size of disk drive)

----------------------- Class 2 (1/11) ------------------------

Interface Evolution - (i.e. internet browsers)
	Changing the interface can be messy because every program must be changed to handle the interface change

	Options attempting to allow remote access to files:
		1) fd = open("file/path", O_RDONLY,);		// makes a system call to open a read-only file and return a descriptor for it
			// Original method which does not provide remote access
		2) fd = open("google.com", "file", O_RDONLY);
			// Problem: function will have difficulty distinguishing 2 argument open from 3 argument open at runtime (won't work)
		3) fd = open("file/path", O_RDONLY, O_REMOTE);
			// Problem: will require interface to be changed drastically, which means changing source code of each application to accomodate (will work, but a lot of work)
		4) open("code.com:file", O_RDONLY);
			// ':' used to signify remote_host:file
			// ':' steals a possible character from filenames - ':' (not ideal)
		5) putenv("FILESERVER=code.com")
			fd = open("file", O_RDONLY);
			FILESERVER=code.com cat f2
			// Problem: Changing environment doesn't allow for multiple parameters
		6) fd = open("file\0code.com", O_RDONLY);
			// '\0' used to signify separation of file\0remote_host
			// Problem: operating system can't tell the difference between original open call and this list of parameters (won't work)
		7) fd = open("code.com/file", O_RDONLY);
			// Problem: directories often have '.' in their name so "code.com" could be a local directory name
		8) fd = open("/u/class/cs111/file", O_RDONLY);
			// "/u/class/cs11" means go look on the remote file system
			// Uses a VERY specific string of "directory" to dictate a remote file system
			// Used on SEASNET server to access remote file systems
			// Table created on SEASNET server to reserve this path name for a remote server

Sample app - no OS:
	Paranoid professor - 10,000 word limit file
	Desktop computer not connected to the internet or the wall power (battery powered)
	Intel core i3-4160 (3 MiB L3 cache 3.6 Ghz)
	Power switch turns on and the monitor tells you how many words are in the file
	Words match [A-Za-z]+ regex
	File is an array of bytes (ASCII) stored on the disk drive

	Priorities in order
	1) Security
	2) Speed

	Questions we need answered:
		- Where is the file located?
			Answer: sector 1,000,000
		- How do we access the file?

	Process:
	1) Turn computer on
	2) Program runs
		- Count words that match [A-Za-z]+ regex expression
		- Increment word counter when hitting non-repeating a character not in expression
		- Display word count

	Disk Drives
		- Rotating magnetic device
		- Separated into sections
		- Closed off from air to prevent dust
		- Disk drive is never touched in fear of scratching
		- To access: controller places read-write head on disk and waits for disk to spin to location that desired data is located
		- Bits of data are arranged in concentric, circular paths called tracks
		- Each track is broken up into smaller areas called sectors (512 bytes per sector)
		- Can send commands or data from CPU to controller
		- History:
			Western Digital
				Integrated Device Electronics (IDE)
				Disk controller: Added a controller that was separate from CPU in 1986
					- Attached to disk drive (ATA = AT Attachment, modernly called PATA = Paralel ATA)
					- Now each controller was tailored to its disk drive and people writing the OS didn't have to handle the controller as well
					- Has a small cache
					- CPU -> 16-bit bus --------------> (controller) -> disk drive
			Modern disk drive implementation
				SATA (Serial ATA)
					Parallel synchronization kills performance
					Hot plugging: can unplug disk drive while drive and CPU are running without causing a fire
					CPU ----- 1-bit-wire -----> controller -> disk drive

	Boostrapping
		- x86 components important to booting:
			1) Physical RAM
				Two main parts:
					a) Real DRAM (real memory)
					b) ROM (Read only memory) 
						- Location on RAM is hardwired into hardware (0xffff0)
						- Contents survive a power outage
						- Stored in EEPROM (Electronically Erasable Programmable Read-Only Memory)
							Set by the manufacturer
							Normally:
								i) 		Tests system
								ii) 	Walk through bus looking for devices
								iii) 	Finds a bootable device
								iv) 	Read device's first sector (512 bytes) into RAM
										- memory location 0x7c00 hardwired into the BIOS
										- memory location 0x7c00 to 0x7dff is modified (512 bytes)
								v)		Jump 0x7c00
						Master Boot Record (MBR) - 512 Bytes (sector 0)
							[||||||||||||  64  |2]
							final 2 byte sector
								- located at 0x55 and 0xAA 0xAA55 (little endian)
								- Boot Signature
							64 bytes: describes an area of disk
								- Contains start sector on disk
								- Size (# sectors)
								- Type (1 byte descriptor of partition, i.e. linux file system, swap partition, microsoft operator)
								- Bootable flag (specifies whether or not it is bootable)
							486 Bytes:
								- x86 code
								- Will be read into memory and executed
						Volume Boot Record (VBR)
							- Using BIOS -> MBR -> VBR = chain loading
							- Runs program called Grand Unified Bootloader (GRUB)
								- Linux Kernal
							- 1 sector of bootable partition


	BIOS
		Job:
			1) Get first sector into RAM
			2) Start running it

	Overview:
		BIOS -> MBR -> VBR -> execute word count code

	Solution to problem above:
		1) BIOS loads in MBR
		2) Jump to 0x7c00 (1st 446-bytes of MBR) and execute Boot Loader source code
		3) This source code will send word count program to RAM to execute

	Boot loader source code
		// At location 0x7c00 run the following code
		// read-write 20 sectors
		// first-argument: sector number
		// second argument: memory address
		// copy data out of disk sector to memory

		// read_ide_sector will read 446 MBR code
		void read_ide_sector(int s, int a)	{
			//PIO
			
			// **************** inb ******************
			// inb is a machine instruction on x86
			// Grabs byte off bus from status register at location 0x147 (
			// Returns current status of disk controller
			// If top two bits of status are 0x40 then it is ready
			// **************** inb ******************
			while((inb(0x147) & 0xc0) != 0x40)
				continue;

			// **************** outb ******************
			outb(0x1f2, 1);					// Setup disk controller to operator on 1 sector w/ next command
			outb(0x1f3, s & 0xff);			
			outb(0x1f4, (s >> 8) & 0xff);
			outb(0x1f5, (s >> 16) & 0xff);
			outb(0x1f6, (s >> 24) & 0xff);
			outb(0x1f7, 0x20); 				// Read sector
			// **************** outb ******************

			// **************** insl ******************
			insl(0x1f0, a, 512 / 4)
		}

		for (i=1; i< 20, i++)	{
			read_ide_sector(i, 0x10000 + (i-1)+512)
		}


// ***************** Discussion: Lab0 / Lab 1A overview ***************** //
Lab 0:
	Read/Write permissions:
		ex: 0644    special: 0(none)
					user: 6 = 4 + 2	(rw)
					group: 4(r)		
					other: 4(r)

	File descriptor	:	default file
	0 				:	stin
	1 				: 	stdout
	2 				: 	stderr
	3 				: 	(open)
	...
	100 			: 	(open)
	...
	...
	...
	Opening a file sets the next avaiable file descriptor to point at the file

	dup2(int oldfd, int newfd, int flag)
	Makes newfd be the copy of oldfd, closing newfd first if necessary

Lab 1:
	Shell script parser
	Test case in spec cannot be passed LOL

	--verbose
	printf("--command 3 5 6 tr A-Z a-z") just before the option is implemented

	Multiple processes:
		pid_t fork(void);
		On success, the PID of the child process is returned in the parent,
		and 0 is returned in the child.  On failure, -1 is returned in the
    	parent, no child process is created, and errno is set appropriately

    	ex:
    		pid_t pid = fork();
    		if (pid == 0)	{
    			// have child process do something
    		}	else if (pid > 0)	{
    			// have parent process do something
    		}	else 	{
    			printf("Error forking processes");
    		}

    	Re-syncing processes:
    		pid_t waitpid(pid_t pid, int *wstatus, int options);

    Execline:
    	int execvp(const char *file, char *const argv[]);
    	Wipes out data but keeps file redirection (stdin, stdout, stderr, etc.)


